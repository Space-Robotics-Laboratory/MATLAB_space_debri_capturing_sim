bl_info ={
    "name": "CSV Importer",
    "author": "Aashish Sarode <aashish.sarode@community.isunet.edu>",
    "version": (1, 0),
    "blender": (3, 2, 0),
    "description": "this importer import the csv data generated from MATLAB and inserts the keyframe as per the data for the animation",
}

import bpy
import csv
import math
import numpy as np

### functions
def reset_target(target_size):
    # remove target if it's already existnig
    exist_target = bpy.data.objects.get('Target')
    if exist_target is not None:
        bpy.data.objects.remove(exist_target, do_unlink=True)
    
    # remake target object
    bpy.ops.mesh.primitive_cube_add(size=target_size)
    cube_obj = bpy.context.object
    cube_obj.name = 'Target'
    return

# apply 3d vec location
def apply_location(obj, row, header_index, matching_indexes, frame_number):
    # get colmun number of first value of position vector
    col = matching_indexes[header_index]
    # all members of vector to float
    location = [float(i) for i in row[col:col+3]]
    # insert the location
    obj.location = location
    #insert the frame for location into timeline
    obj.keyframe_insert(data_path="location", frame=frame_number) 

# apply 3d vec orientation
def apply_orientation(obj, row, header_index, matching_indexes, frame_number):
    # get colmun number of first value of [roll, pitch, yaw] vector
    col = matching_indexes[header_index]
    # all members of vector to float
    rot_euler = [float(i) for i in row[col:col+3]]
#    rot_euler = np.rad2deg(rot_data)
    # insert the location
    obj.rotation_euler = rot_euler
    #insert the frame for location into timeline
    obj.keyframe_insert(data_path="rotation_euler", frame=frame_number)  

# apply 8d  vec joint angle
def apply_angle(obj_list, row, header_index, matching_indexes, frame_number):
    # get colmun number of first value of [roll, pitch, yaw] vector
    col = matching_indexes[header_index]    
    angle = [float(i) for i in row[col:col+8]]
#    angle = np.rad2deg(angle_data)
    i = 0
    for obj in obj_list:
        obj.rotation_euler = (0, 0, angle[i])
        obj.keyframe_insert(data_path="rotation_euler", frame=frame_number)
        i += 1


### main
# insert the file path of csv file generated by MATLAB in single inverted commas
csvfilename = "/Users/akiyoshi/develop/srl/github/MATLAB_space_debri_capturing_sim/two-dimensional/uchida_program/dat/2023-0324/direct/20_1000-dat/savedDat.csv"
# set animation frame rate
dt_simu = 0.001
frameRate_anime = 50
freq_anime = 1/frameRate_anime
freq_roop = 1/ (dt_simu * frameRate_anime)
bpy.context.scene.render.fps = frameRate_anime

# reset target 
reset_target(0.16)

#Define the objects and bones in the model
L1 = bpy.data.objects["Left Arm"].pose.bones["Link 1"]
L2 = bpy.data.objects["Left Arm"].pose.bones["Link 2"]
L3 = bpy.data.objects["Left Arm"].pose.bones["Link 3"]
L3B = bpy.data.objects["Left Arm"].pose.bones['Link 3B']
L3A = bpy.data.objects["Left Arm"].pose.bones['Link 3A']
L4 = bpy.data.objects["Right Arm"].pose.bones["Link 4"]
L5 = bpy.data.objects["Right Arm"].pose.bones["Link 5"]
L6 = bpy.data.objects["Right Arm"].pose.bones["Link 6"]
L6B = bpy.data.objects["Right Arm"].pose.bones['Link 6B']
L6A = bpy.data.objects["Right Arm"].pose.bones['Link 6A']
Links = [L1, L2, L3, L3A, L4, L5, L6, L6A]
B = bpy.data.objects["DualArmRobo"].pose.bones["Bone"]
T = bpy.data.objects["Target"]
fn = 0
count = 0

with open(csvfilename, newline='', encoding='utf-8-sig') as csvfile:
    csvreader = csv.reader(csvfile, delimiter=',')
    headers = next(csvreader)
    # make header index
    # important: it's required to sort them as the same order of csv header
    search_headers = ["roboR0_1", "roboQ0_1", "jointAng_1", "targR0_1", "targQ0_1"]
    matching_indexes = [i for i, header in enumerate(headers) if header in search_headers]
    if headers != None:
        for row in csvreader:
            # write anime if time is devided by frequency
            if count % freq_roop == 0:
                # apply move on robot
                apply_location(B, row, 0, matching_indexes, fn)
                apply_orientation(B, row, 1, matching_indexes, fn)
                apply_angle(Links, row, 2, matching_indexes, fn)
                # apply move on target
                apply_location(T, row, 3, matching_indexes, fn)
                apply_orientation(T, row, 4, matching_indexes, fn)
                fn += 1
            count += 1
bpy.context.scene.frame_end = fn
csvfile.close()